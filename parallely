#!/usr/bin/env bash

# TODO mark each global variable
# TODO are there local variables in POSIX shellscripts?

############## Shell flags
# Exit on error, undeclared variable reference, and set pipeline exit code
# to that of failing command.
set -eu

# Enable for debugging:
DEBUG="${DEBUG-false}"
TRACE="${TRACE-false}"

if [ "$TRACE" = true ]; then
  set -x
fi

############## Constants
SCRIPT_NAME="parallely"
VERSION=1.6.0
# For some reason, plain "\n" doesn't work with test
NEWLINE="$(printf "\n")"

############## Exit codes
NO_ARGUMENTS_EXIT_CODE=89
NOT_ENOUGH_ARGUMENTS_EXIT_CODE=87
REPEATED_NAME_EXIT_CODE=86
MISSING_OPTARG_EXIT_CODE=85
UNKNOWN_LONG_OPTION_EXIT_CODE=81
UNKNOWN_SHORT_OPTION_EXIT_CODE=82
COMPOUND_SHORT_OPTION_EXIT_CODE=83
NEWLINE_IN_NAME_EXIT_CODE=99
COMMANDS_FAILED_EXIT_CODE=2

############## Constants, but they might become configurable
DEFAULT_CMD_SHELL="sh"
DEFAULT_CMD_SHELL_ARGS="-c"
SHOW_CMD_OUTPUT_CMD_DEFAULT="tail -n1"
NO_OUTPUT_INDICATOR="(no output)"
NO_EOF_NEWLINE_INDICATOR="(no newline at end of output)"

############## Configurable environment variables.
# These should be in the same order as the argument parser and the documentation
if [ -n "${VERBOSE-}" ]; then
  PARALLELY_VERBOSE_OUTPUT="$VERBOSE"
fi
PARALLELY_VERBOSE_OUTPUT="${PARALLELY_VERBOSE_OUTPUT-false}"

if [ -n "${ALL_OUTPUT-}" ]; then
  PARALLELY_SHOW_ALL_OUTPUT="$ALL_OUTPUT"
fi
PARALLELY_SHOW_ALL_OUTPUT="${PARALLELY_SHOW_ALL_OUTPUT-$PARALLELY_VERBOSE_OUTPUT}"

# If output is not a tty or DISPLAY is unset
# don't show emoji
if ! [ -t 1 ] || [ -z "${DISPLAY-}" ]; then
  PARALLELY_EMOJI_OUTPUT="${PARALLELY_EMOJI_OUTPUT-false}"
fi
PARALLELY_EMOJI_OUTPUT="${PARALLELY_EMOJI_OUTPUT-true}"

FORCE_SEQUENTIAL="${FORCE_SEQUENTIAL-false}"

# If output is not a tty
# disable colors
if ! [ -t 1 ]; then
  ENABLE_COLORS="${ENABLE_COLORS-false}"
fi
ENABLE_COLORS="${ENABLE_COLORS-true}"

CMD_SHELL="${CMD_SHELL-$DEFAULT_CMD_SHELL $DEFAULT_CMD_SHELL_ARGS}"

if [ -z "${SHOW_CMD_OUTPUT_CMD-}" ]; then
  SHOW_CMD_OUTPUT_CMD="$SHOW_CMD_OUTPUT_CMD_DEFAULT"
fi

# If $DISPLAY is not set
# use CLI to notify about commands finishing
if [ -z "${DISPLAY-}" ]; then
  CLI_NOTIFY="${CLI_NOTIFY-true}"
fi
CLI_NOTIFY="${CLI_NOTIFY-false}"


if [ -z "${NOTIFY_COMMAND-}" ]; then
  if [ "$CLI_NOTIFY" = true ]; then
    NOTIFY_COMMAND="echo"
  else
    NOTIFY_COMMAND="notify-send"
  fi
fi

if [ -z "${FAILURE_NOTIFY_COMMAND-}" ]; then
  if [ "$CLI_NOTIFY" = true ]; then
    FAILURE_NOTIFY_COMMAND="echo" 
  else
    FAILURE_NOTIFY_COMMAND="notify-send --urgency=critical"
  fi
fi

SHOW_CONFIGURATION="${SHOW_CONFIGURATION-false}" 

############## Other variables
CURRENT_CMD=0

CMD_OUT_DIR="$(mktemp --directory)/$SCRIPT_NAME-logs-$(whoami)-$(date +%Y-%m-%d)"
mkdir -p "$CMD_OUT_DIR"

# Stores array of PIDs of commands that were started
# Due to POSIX compatibility, we can't use arrays.
pids=""

############## Functions to help generate output
# TODO use tput
BLUE=34
RED=31
GREY=37
NONE=0
color() {
  if [ "$ENABLE_COLORS" = true ]; then
    printf "\\e[%sm" "$1"
  fi
}

emoji() {
  if [ "$PARALLELY_EMOJI_OUTPUT" != true ]; then
    return 0
  fi

  trailer=' '
  if [ "${2-}" = nospace ]; then
    trailer=
  fi
  character=
  case "$1" in
    checkmark) character='âœ…' ;;
    error) character='âŒ' ;;
    rocket) character='ðŸš€' ;;
  esac
  if [ -z "$character" ]; then
    error Unknown emoji "$1"
  fi
  printf "%s%s" "$character" "$trailer"
}

log() {
  echo "$@"
}

log_color() {
  color "$1"
  shift
  log "$@"
  color "$NONE"
}

verbose() {
  if [ "${FORCE_LOG-false}" = true ] || [ "$PARALLELY_VERBOSE_OUTPUT" = true ] ; then
    log_color "$BLUE" "$@"
  fi
}

debug() {
  if [ "${DEBUG-}" = true ]; then
    echo "$@"
  fi
}

section_str() {
  color 3
  color 1
  log ============= "$@" =============
  color "$NONE"
}

section() {
  log "$(section_str "$@")"
}

verbose_section() {
  verbose "$(section_str "$@")"
}

# Logs to stderr
error_section() {
  color "$RED"
  section "$@" >&2
  color "$NONE"
}

# Logs to stderr
error() {
  log_color "$RED" "$(emoji error)ERROR" "$@" >&2
}

time_in_sec() {
  date +%s.%N
}

float_to_int() {
  echo "$1" | cut -d\. -f1
}

noun() {
  if [ "$(float_to_int "$1")" = 1 ]; then
    echo "$2"
  else
    echo "$2"s
  fi
}

############## Help
help() {
  # I tried changing this to one large multi-line string, but it messes with
  # my editor's syntax highlighting and I can't move the function to the end
  # of the file without more complicated code.
  echo "Description:"
  echo "    Run commands in parallel and capture output. Notify on each completion."
  echo
  echo "    - Notify if a command succeeds (status code 0) or fails (non-zero status code)."
  echo "    - Save command outputs to a temporary directory."
  echo "    - Print command output if the command fails."
  echo
  echo "    See examples in section below."
  echo
  echo "USAGE:"
  echo "    $SCRIPT_NAME -h|--help|-v|--version|<other options> [cmd_name cmd_with_arguments]+"
  echo
  echo "    One or more pairs of cmd_name followed by cmd_with_arguments are expected."
  echo
  echo "    cmd_name             A short and filesafe name for the following command."
  echo "                         Used in notifications and files storing output."
  echo "                         A cmd_with_arguments should always follow these args."
  echo "    cmd_with_arguments   An escaped command to run in parallel"
  echo
  echo "    -h|--help            Print this message."
  echo "    -v|--version         Print version of this script."
  echo
  echo "Configuration:"
  echo "  Options take priority over environment variables."
  echo "  Options can go in between a name and its command."
  echo "  Use --show-configuration or --verbose to see configuration."
  echo
  echo "  Output configuration:"
  echo "    --verbose|-V|--no-verbose or set \$PARALLELY_VERBOSE_OUTPUT=true:"
  echo "        Whether to print verbose logs."
  printf '%s' \
       "        If colors are enabled, logs are "
  log_color "$BLUE" "colored."
  echo "        Default: false or value of \$VERBOSE if it is set"
  echo "    --all-output|-a|--not-all-output or set \$PARALLELY_SHOW_ALL_OUTPUT=true:"
  echo "        Whether to print command output for successful commands too."
  echo "        Default: false or value of \$ALL_OUTPUT if it is set"
  echo "    --emoji|-e|--no-emoji|-z or set \$PARALLELY_EMOJI_OUTPUT=true:"
  echo "        Whether to print emoji."
  echo "        Default: true if output is a tty and \$DISPLAY is set, false otherwise."
  echo "    --color|-c|--no-color|-n or set \$ENABLE_COLORS=true: "
  printf '%s' \
       "        If enabled, errors are "
  log_color "$RED" "colored."
  echo "        Default: true if output is a tty, false otherwise."
  echo "    --command-output-command or set \$SHOW_CMD_OUTPUT_CMD:"
  echo "        Command for printing stderr and stdout of a command/"
  echo "        Default: $SHOW_CMD_OUTPUT_CMD_DEFAULT"
  echo "        Example values:"
  echo "          Show all output: cat"
  echo "          Show last ten lines: tail -n10"
  echo "          Show output for each command one at a time: less"
  echo "  Running commands configuration:"
  echo "    --sequential|-s|--no-sequential or set \$FORCE_SEQUENTIAL=true:"
  echo "        Run commands sequentially instead of in parallel."
  echo "        Useful if you just want to capture output and get notifications."
  echo "        Default: false"
  echo "    --shell-command or set \$CMD_SHELL:"
  echo "        Which shell to run the commands in."
  echo "        Default: $DEFAULT_CMD_SHELL $DEFAULT_CMD_SHELL_ARGS"
  echo "  Notifications configuration:"
  echo "    --notify-command or set \$NOTIFY_COMMAND:"
  echo "        Command to notify when a command succeeds."
  echo "        Should take two arguments, each possibly containing spaces."
  echo "        First argument is title, second is a description."
  echo "        Default: echo if \$CLI_NOTIFY is false, GUI command otherwise."
  echo "    --failure-notify-command or set \$FAILURE_NOTIFY_COMMAND:"
  echo "        Command to notify when a command fails."
  echo "        Should take two arguments, each possibly containing spaces."
  echo "        First argument is title, second is a description."
  echo "        Default: echo if \$CLI_NOTIFY is false, more visible GUI command otherwise."
  echo
  echo "  Debug only:"
  echo "    --show-configuration or set \$SHOW_CONFIGURATION=true:"
  echo "        Print configuration."
  echo "    --debug or set \$DEBUG=true"
  echo "    --trace or set \$TRACE=true:"
  echo "        Run 'set -x'"
  echo
  echo "Examples:"
  echo
  echo "  Multiple commands:"
  echo "    $SCRIPT_NAME fail 'echo failure && exit 1' \\"
  echo "      fail-printf-nonewline 'printf \"%s %s\"\\ abc 123 ; false' \\"
  echo "      fail-rsync-src 'rsync -rhP nonexistentdir backup' \\"
  echo "      delay 'sleep 0.2' \\"
  echo "      ok-and-output 'echo test ; echo stderr test >&2' \\"
  echo "      fail-slower-delay '! sleep 0.4' \\"
  echo "      fail-no-output 'exit 210' \\"
  echo "      'long name for command with spaces' 'true && echo ok'"
  echo
  echo "    The odd numbered arguments are short, filesafe names for each command." 
  echo "    The names are used in notifications and files storing outout."
  echo
  echo "  A command without arguments:"
  echo "    $SCRIPT_NAME list-files ls"
  echo
  echo "  Verbose output and a command without arguments:"
  echo "    $SCRIPT_NAME -V list-files ls"
  echo "    $SCRIPT_NAME list-files ls -V"
  echo "    $SCRIPT_NAME list-files -V ls"
  echo "    VERBOSE=true $SCRIPT_NAME list-files ls"
  echo "    PARALLELY_VERBOSE_OUTPUT=true $SCRIPT_NAME list-files ls"
  echo
  echo "  A command with arguments:"
  echo "    $SCRIPT_NAME rsync-src 'rsync -rhP src backup'"
  echo
  echo "  A command with arguments that have spaces in them:"
  echo "    $SCRIPT_NAME printf-abc 'printf \"%s %s\" abc 123'"
  echo
  echo "  Shell commands:"
  echo "    $SCRIPT_NAME test-exit 'echo failure && exit 1'"
  echo "    $SCRIPT_NAME test-statement 'if true; then echo 1; fi'"
  echo
  echo "    Commands are run in the $DEFAULT_CMD_SHELL by default shell with: $CMD_SHELL \"\$COMMAND\""
  echo
  echo "  Commands are waited one at a time in order:"
  echo "    This means that you should list the fast commands first."
  echo "    VERBOSE=true $SCRIPT_NAME 1 'sleep 0.1' 2 'sleep 1' 3 'sleep 2'"
  echo
  echo "    Or else, it'll take a bit longer to see successful outputs."
  echo "    VERBOSE=true $SCRIPT_NAME 3 'sleep 2' 2 'sleep 1' 1 'sleep 0.1'"
  echo
  echo "    Regardless, you are notified as soon as a command finishes."
  echo "    VERBOSE=true CLI_NOTIFY=true parallely 3 'sleep 2' 2 'sleep 1' 1 'sleep 0.1'"
  echo
  echo "Contributors: Hugo O. Rivera"
  echo "Version: $VERSION"
}

############## Main functions

run_cmd() {
  # Run a command in background and save its stderr and stdout to files
  NAME="$1"
  COMMAND="$2"
  STDERR_FILE="$CMD_OUT_DIR/$NAME.stderr"
  STDOUT_FILE="$CMD_OUT_DIR/$NAME.stdout"
  TIME_FILE="$CMD_OUT_DIR/$NAME.time"

  verbose "Starting $NAME command $CURRENT_CMD/$NUM_CMDS"
  verbose + "$CMD_SHELL" "$COMMAND"

  # Run command and then run notify command.
  # If either notify command fails, do not count the command as a failed command
    ( \
      ( \
        export START_TIME="$(time_in_sec)" \
        ; \
        $CMD_SHELL \
        "$COMMAND" > "$STDOUT_FILE" 2> "$STDERR_FILE" \
        ; \
        export STATUS_CODE="$?" \
        ; \
        echo "$(time_in_sec)" "$START_TIME" | awk '{print $1 - $2}' > "$TIME_FILE" \
        ; \
        exit "$STATUS_CODE" \
        ; \
      ) \
      && ( \
        $NOTIFY_COMMAND "parallely: $NAME command finished" "$COMMAND" \
        || true \
      ) \
    ) \
    || ( \
      $FAILURE_NOTIFY_COMMAND "parallely: $NAME command failed" "$COMMAND" \
      && false \
    ) \
    &
  PID="$!"
  pids="$pids $PID"
  PID_FILE="$CMD_OUT_DIR/$PID"
  echo "$NAME" > "$PID_FILE"

  if [ "$FORCE_SEQUENTIAL" = true ]; then
    log "FORCE_SEQUENTIAL is set: Waiting for command $NAME to finish"
    wait "$PID" || true
  fi
}

############## Parse arguments

validate_option_argument() {
  debug "arglog: Validating optarg: \"$ARGUMENT\""
  if [ -z "$ARGUMENT" ]; then
    error Option "$OPTION" expected argument
    exit "$MISSING_OPTARG_EXIT_CODE"
  fi
  PARSED_ARGUMENT=true
}

OPTION=
ARGUMENT=
parse_option() {
  # Parse an individual option.
  # It can either set a variable, cause the program to exit,
  # or set the current name or command, which must come in pairs.
  OPTION="$1"
  ARGUMENT="${2-}"
  debug "arglog: Option=\"$OPTION\""
  case "$OPTION" in
    --help | -h)
      help
      exit 0
      ;;
    --version | -v) 
      log "$VERSION"
      exit 0
      ;;
    --verbose | -V) PARALLELY_VERBOSE_OUTPUT=true ;;
    --no-verbose) PARALLELY_VERBOSE_OUTPUT=false ;;
    --all-output | -a) PARALLELY_SHOW_ALL_OUTPUT=true ;;
    --not-all-output) PARALLELY_SHOW_ALL_OUTPUT=false ;;
    --emoji | -e) PARALLELY_EMOJI_OUTPUT=true ;;
    --no-emoji | -z) PARALLELY_EMOJI_OUTPUT=false ;;
    --color | -c) ENABLE_COLORS=true ;;
    --no-color | -n) ENABLE_COLORS=false ;;
    --command-output-command) validate_option_argument "$ARGUMENT" ; SHOW_CMD_OUTPUT_CMD="$ARGUMENT" ;;
    --sequential | -s) FORCE_SEQUENTIAL=true ;;
    --no-sequential) FORCE_SEQUENTIAL=false ;;
    --shell-command) validate_option_argument "$ARGUMENT" ; CMD_SHELL="$ARGUMENT" ;;
    --notify-command) validate_option_argument "$ARGUMENT" ; NOTIFY_COMMAND="$ARGUMENT" ;;
    --failure-notify-command) validate_option_argument "$ARGUMENT" ; FAILURE_NOTIFY_COMMAND="$ARGUMENT" ;;
    --show-configuration) SHOW_CONFIGURATION=true ;;
    --debug) DEBUG=true ;;
    --trace) set -x ;;
    --*=*)
      error "Long options with argument set with = are not allowed: given $OPTION"
      log "Use --option argument instead of --option=argument"
      exit "$UNKNOWN_LONG_OPTION_EXIT_CODE"
      ;;
    --*)
      error Unrecognized option "$OPTION"
      exit "$UNKNOWN_LONG_OPTION_EXIT_CODE"
      ;;
    -*)
      if [ "$(echo "$OPTION" | wc -c)" -gt 3 ]; then
        error Compound short options are not allowed: given "$OPTION"
        log "Use -a -b instead of -ab"
        exit "$COMPOUND_SHORT_OPTION_EXIT_CODE"
      else
        error Unrecognized option "$OPTION"
        exit "$UNKNOWN_SHORT_OPTION_EXIT_CODE"
      fi
      ;;
    # Indicate option is a name or command
    *) 
      if [ "$EXPECTING_ARG" = name ]; then
        # Rare case: name contains newline.
        # I had trouble detecting this condition..
        CURRENT_NAME="$OPTION"
      elif [ "$EXPECTING_ARG" = command ]; then
        CURRENT_COMMAND="$OPTION"
      fi
      return 1 ;;
  esac
  return 0
}

############## Parse command line arguments
if [ "$#" = 0 ]; then
  help
  error No arguments given.
  exit "$NO_ARGUMENTS_EXIT_CODE"
fi

NAMES_FILE="$CMD_OUT_DIR/names"
debug "arglog: Will parse ($#) arguments:"
for arg in "$@"; do
  debug "arglog: Argument \"$arg\""
done
while [ "$#" -gt 0 ]; do
  # This code is complicated because we need to parse arbitrary options
  # among pairs of non-option arguments.
  CURRENT_NAME=
  CURRENT_COMMAND=
  PARSED_ARGUMENT=false 
  EXPECTING_ARG=name

  # Parse options and loop or parse the name/command and end loop
  # This code must be duplicated because functions do not have
  # access to the program's arguments, only their own
  while [ "$#" -gt 0 ] && parse_option "$1" "${2-}"; do
    shift
    if [ "$PARSED_ARGUMENT" = true ]; then
      debug "arglog: Option $OPTION argument $ARGUMENT was parsed"
      shift
    fi
    PARSED_ARGUMENT=false 
  done
  debug "arglog: Remaining ($#)" "$@"

  if [ -n "$CURRENT_NAME" ]; then
    shift
  else
    # All arguments were parsed successfully. End the loop.
    continue
  fi

  EXPECTING_ARG=command

  # Parse options and loop or parse the name/command and end loop
  # This code must be duplicated because functions do not have
  # access to the program's arguments, only their own
  while [ "$#" -gt 0 ] && parse_option "$1" "${2-}"; do
    shift
    if [ "$PARSED_ARGUMENT" = true ]; then
      debug "arglog: Option $OPTION argument $ARGUMENT was parsed"
      shift
    fi
    PARSED_ARGUMENT=false 
  done
  debug "arglog: Remaining ($#)" "$@"
  
  if [ -n "$CURRENT_COMMAND" ]; then
    shift
  else
    # Handle name without a command
    if [ "$#" = 0 ]; then
      error "Not enough arguments found! Please write the command for $CURRENT_NAME"
      log "Are your arguments containing spaces properly escaped?"
      exit "$NOT_ENOUGH_ARGUMENTS_EXIT_CODE"
    fi
  fi

  # Check for repeated names
  if grep "^$CURRENT_NAME$" "$NAMES_FILE" &> /dev/null; then
    error "Duplicate name $CURRENT_NAME detected. Please rename."
    exit "$REPEATED_NAME_EXIT_CODE"
  fi
  echo "$CURRENT_NAME" >> "$NAMES_FILE"

  # Save command so it can be accessed by command name.
  # Since we can't guarantee access to bash arrays, we don't have a way to
  # save commands that contain whitespace or nested strings properly.
  COMMAND_FILE="$CMD_OUT_DIR/$CURRENT_NAME.command"
  echo "$CURRENT_COMMAND" > "$COMMAND_FILE"
done

NEWLINE_AFTER_EVERY_ERROR=false
if [ "$PARALLELY_VERBOSE_OUTPUT" = true ]; then
  NEWLINE_AFTER_EVERY_ERROR=true
fi

NUM_CMDS="$(cat "$NAMES_FILE" | wc -l)"

############## Print configuration

show_configuration() {
  section Configuration
  log "Environment variables may have been overridden by command line options."
  log
  log "PARALLELY_VERBOSE_OUTPUT=$PARALLELY_VERBOSE_OUTPUT"
  log "PARALLELY_SHOW_ALL_OUTPUT=$PARALLELY_SHOW_ALL_OUTPUT"
  log "PARALLELY_EMOJI_OUTPUT=$PARALLELY_EMOJI_OUTPUT"
  log "CMD_SHELL=$CMD_SHELL"
  log "FORCE_SEQUENTIAL=$FORCE_SEQUENTIAL"
  log "SHOW_CMD_OUTPUT_CMD=$SHOW_CMD_OUTPUT_CMD"
  log "NOTIFY_COMMAND=$NOTIFY_COMMAND"
  log "FAILURE_NOTIFY_COMMAND=$FAILURE_NOTIFY_COMMAND"
  log "ENABLE_COLORS=$ENABLE_COLORS"
  log "Temporary directory CMD_OUT_DIR=$CMD_OUT_DIR"
  log
}

if [ "$FORCE_SEQUENTIAL" = true ]; then
  RUN_METHOD=sequentially
else
  RUN_METHOD='in parallel'
fi

log "$SCRIPT_NAME will run $NUM_CMDS commands $RUN_METHOD $(emoji rocket)"

if [ "$PARALLELY_VERBOSE_OUTPUT" = true ] || [ "$SHOW_CONFIGURATION" = true ]; then
  show_configuration
fi

############## Main loop

# Iterate through all given command line arguments.
# Run each one as a command in parallel, saving its output to a tmp file.
START_TIME="$(time_in_sec)"
verbose_section Starting commands
while read NAME; do
  COMMAND_FILE="$CMD_OUT_DIR/$NAME.command"
  CURRENT_CMD="$(( CURRENT_CMD + 1))"
  run_cmd "$NAME" "$(cat "$COMMAND_FILE")"
done < "$NAMES_FILE"

verbose

############## Wait for commands and show results, especially from failed commands
show_output() {
  # Print output of a command
  DISPOSITION="$1"
  OUTPUT_NAME="$2"
  NAME="$3"
  FILE="$4"
  printf "%s" "$(color "$BLUE")$OUTPUT_NAME$(color "$NONE") output for $DISPOSITION command $NAME:"
  if [ -z "$(cat "$FILE")" ]; then
    log_color "$GREY" " $NO_OUTPUT_INDICATOR"
  else
    log
    log + "$SHOW_CMD_OUTPUT_CMD" "$FILE"
    $SHOW_CMD_OUTPUT_CMD "$FILE"
    if [ "$(tail -c1 "$FILE")" != "$NEWLINE" ]; then
      log
      log_color "$GREY" "$NO_EOF_NEWLINE_INDICATOR"
    fi
  fi
}

subtract_two_floats() {
  A="$1"
  B="$2"
  SUBTRACT_FAILURE=false
  if command -v awk &> /dev/null; then
    if ! echo "$A" "$B" | awk '{print $1-$2}'; then
      error "awk is not working! Please redefine the subtract_two_floats function"
      SUBTRACT_FAILURE=true
    fi
  else
    error "awk is not available! Please redefine the subtract_two_floats function"
    SUBTRACT_FAILURE=true
  fi
  
  if [ "$SUBTRACT_FAILURE" = true ]; then
    echo "$A - $B"
  fi
}

FAILURE=false
FAILED_CMDS=""
FAILURES=0
SUCCESS=0
# Due to POSIX compatibility, we can't use arrays.
failedpids=""
# Wait for commands
verbose_section Waiting for commands to finish
verbose Will list successful and failed commands.
verbose
FORCE_LOG=false
if [ "$PARALLELY_VERBOSE_OUTPUT" != true ] && [ "$PARALLELY_SHOW_ALL_OUTPUT" = true ]; then
  FORCE_LOG=true
fi

for PID in $pids; do
  if wait "$PID"; then
    SUCCESS="$((SUCCESS + 1))"
    if [ "$SUCCESS" = 1 ]; then
      verbose_section "Successful command(s)"
    fi

    NAME="$(cat "$CMD_OUT_DIR/$PID")"
    STDERR_FILE="$CMD_OUT_DIR/$NAME.stderr"
    STDOUT_FILE="$CMD_OUT_DIR/$NAME.stdout"
    TIME="$(cat "$CMD_OUT_DIR/$NAME.time")"
    COMMAND="$(cat "$CMD_OUT_DIR/$NAME.command")"
    verbose "$(emoji checkmark)Command $NAME succeeded in $TIME seconds."
    verbose + "$COMMAND"
    verbose "$STDERR_FILE"
    verbose "$STDOUT_FILE"
    if [ "$PARALLELY_SHOW_ALL_OUTPUT" = true ]; then
      show_output successful STDERR "$NAME" "$STDERR_FILE"
      show_output successful STDOUT "$NAME" "$STDOUT_FILE"
    fi
    verbose
  else
    FAILURE=true
    failedpids="$failedpids $PID"
  fi
done
FORCE_LOG=false

for PID in $failedpids; do
  FAILURES="$((FAILURES + 1))"
  NAME="$(cat "$CMD_OUT_DIR/$PID")"
  FAILED_CMDS="$NAME $FAILED_CMDS"

  if [ "$FAILURES" = 1 ]; then
    error_section "Failed command $(noun "$(echo "$failedpids" | wc -w)" output)"
  fi

  STDERR_FILE="$CMD_OUT_DIR/$NAME.stderr"
  STDOUT_FILE="$CMD_OUT_DIR/$NAME.stdout"
  TIME="$(cat "$CMD_OUT_DIR/$NAME.time")"
  COMMAND="$(cat "$CMD_OUT_DIR/$NAME.command")"
  error "Failure in command $NAME after $TIME seconds"
  log + "$COMMAND"
  log "$STDERR_FILE"
  log "$STDOUT_FILE"
  show_output failed STDERR "$NAME" "$STDERR_FILE"
  show_output failed STDOUT "$NAME" "$STDOUT_FILE"
  if [ "$NEWLINE_AFTER_EVERY_ERROR" = true ]; then
    log
  fi
done

TOTAL_TIME="$(subtract_two_floats "$(time_in_sec)" "$START_TIME")"

############## Print summary and timing
verbose_section SUMMARY
verbose "$SUCCESS $(noun "$SUCCESS" command) succeeded"
log "$NUM_CMDS $(noun "$NUM_CMDS" command) finished in $TOTAL_TIME $(noun "$TOTAL_TIME" second)"
if [ "$FAILURE" = true ]; then
  error "$FAILURES/$NUM_CMDS $(noun "$FAILURES" command) failed: $FAILED_CMDS"
  exit "$COMMANDS_FAILED_EXIT_CODE"
fi
