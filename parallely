#!/usr/bin/env bash

############## Shell flags
# Exit on error, undeclared variable reference, and set pipeline exit code
# to that of failing command.
set -eu

############## Constants
SCRIPT_NAME="parallely"
VERSION=1.6.0

############## Constants, but they might become configurable
DEFAULT_CMD_SHELL="sh"
CMD_SHELL_ARGS="-c"
SHOW_CMD_OUTPUT_CMD_DEFAULT="tail -n1"
NO_OUTPUT_INDICATOR="(no output)"
NO_EOF_NEWLINE_INDICATOR="(no newline at end of output)"

############## Configurable environment variables
CMD_SHELL="${CMD_SHELL-$DEFAULT_CMD_SHELL}"
CMD_SHELL_WITH_ARGS="$CMD_SHELL $CMD_SHELL_ARGS"

FORCE_SEQUENTIAL="${FORCE_SEQUENTIAL-false}"

if [ -n "${VERBOSE-}" ]; then
  PARALLELY_VERBOSE_OUTPUT="$VERBOSE"
fi
PARALLELY_VERBOSE_OUTPUT="${PARALLELY_VERBOSE_OUTPUT-false}"

if [ -n "${ALL_OUTPUT-}" ]; then
  PARALLELY_SHOW_ALL_OUTPUT="$ALL_OUTPUT"
fi
PARALLELY_SHOW_ALL_OUTPUT="${PARALLELY_SHOW_ALL_OUTPUT-$PARALLELY_VERBOSE_OUTPUT}"

if [ -z "${SHOW_CMD_OUTPUT_CMD-}" ]; then
  SHOW_CMD_OUTPUT_CMD="$SHOW_CMD_OUTPUT_CMD_DEFAULT"
fi

# If $DISPLAY is not set
# use CLI to notify about commands finishing
if [ -z "${DISPLAY-}" ]; then
  CLI_NOTIFY="${CLI_NOTIFY-true}"
fi
CLI_NOTIFY="${CLI_NOTIFY-false}"


if [ -z "${NOTIFY_COMMAND-}" ]; then
  if [ "$CLI_NOTIFY" = true ]; then
    NOTIFY_COMMAND="echo"
  else
    NOTIFY_COMMAND="notify-send"
  fi
fi

if [ -z "${FAILURE_NOTIFY_COMMAND-}" ]; then
  if [ "$CLI_NOTIFY" = true ]; then
    FAILURE_NOTIFY_COMMAND="echo" 
  else
    FAILURE_NOTIFY_COMMAND="notify-send --urgency=critical"
  fi
fi

# If output is not a tty
# disable colors
if ! [ -t 1 ]; then
  ENABLE_COLORS="${ENABLE_COLORS-false}"
fi
ENABLE_COLORS="${ENABLE_COLORS-true}"

# If output is not a tty or DISPLAY is unset
# don't show emoji
if ! [ -t 1 ] || [ -z "${DISPLAY-}" ]; then
  PARALLELY_EMOJI_OUTPUT="${PARALLELY_EMOJI_OUTPUT-false}"
fi
PARALLELY_EMOJI_OUTPUT="${PARALLELY_EMOJI_OUTPUT-true}"

############## Other variables
NUM_CMDS="$(($# / 2 ))"
CURRENT_CMD=0

CMD_OUT_DIR="$(mktemp --directory)/$SCRIPT_NAME-logs-$(whoami)-$(date +%Y-%m-%d)"
mkdir -p "$CMD_OUT_DIR"

NEWLINE_AFTER_EVERY_ERROR=false
if [ "$PARALLELY_VERBOSE_OUTPUT" = true ]; then
  NEWLINE_AFTER_EVERY_ERROR=true
fi

# Stores array of PIDs of commands that were started
pids=""

############## Utility functions
# TODO use tput
BLUE=34
RED=31
GREY=37
NONE=0
color() {
  if [ "$ENABLE_COLORS" = true ]; then
    printf "\\e[%sm" "$1"
  fi
}

emoji() {
  if [ "$PARALLELY_EMOJI_OUTPUT" != true ]; then
    exit 0
  fi

  trailer=' '
  if [ "${2-}" = nospace ]; then
    trailer=
  fi
  character=
  case "$1" in
    checkmark) character='✅' ;;
    error) character='❌' ;;
    rocket) character='🚀' ;;
  esac
  if [ -z "$character" ]; then
    error Unknown emoji "$1"
  fi
  printf "%s%s" "$character" "$trailer"
}

log() {
  echo "$@"
}

log_color() {
  color "$1"
  shift
  log "$@"
  color "$NONE"
}

verbose() {
  if [ "${FORCE_LOG-false}" = true ] || [ "$PARALLELY_VERBOSE_OUTPUT" = true ] ; then
    log_color "$BLUE" "$@"
  fi
}

section_str() {
  color 3
  color 1
  log ============= "$@" =============
  color "$NONE"
}

section() {
  log "$(section_str "$@")"
}

verbose_section() {
  verbose "$(section_str "$@")"
}

# Logs to stderr
error_section() {
  color "$RED"
  section "$@" >&2
  color "$NONE"
}

# Logs to stderr
error() {
  log_color "$RED" "$(emoji error)ERROR" "$@" >&2
}

time_in_sec() {
  date +%s.%N
}

float_to_int() {
  echo "$1" | cut -d\. -f1
}

noun() {
  if [ "$(float_to_int "$1")" = 1 ]; then
    echo "$2"
  else
    echo "$2"s
  fi
}

############## Help
help() {
  echo "Description:"
  echo "    Run commands in parallel and capture output. Notify on each completion."
  echo
  echo "    - Notify if a command succeeds (status code 0) or fails (non-zero status code)."
  echo "    - Save command outputs to a temporary directory."
  echo "    - Print command output if the command fails."
  echo
  echo "    See examples in section below."
  echo
  echo "USAGE:"
  echo "    $SCRIPT_NAME -h|--help|-v|--version"
  echo "    $SCRIPT_NAME [cmd_name cmd_with_arguments]+"
  echo
  echo "    One or more pairs of cmd_name followed by cmd_with_arguments are expected."
  echo
  echo "    -h|--help            Print this message."
  echo "    -v|--version         Print version of this script."
  echo "    cmd_name             A short and filesafe name for the following command."
  echo "                         Used in notifications and files storing output."
  echo "                         A cmd_with_arguments should always follow these args."
  echo "    cmd_with_arguments   An escaped command to run in parallel"
  echo
  echo "Environment variables:"
  echo "  Output:"
  echo "    \$PARALLELY_VERBOSE_OUTPUT:"
  echo "        Whether to print verbose logs."
  printf '%s' \
       "        If colors are enabled, logs are "
  log_color "$BLUE" "colored."
  echo "        Default: false or value of \$VERBOSE if it is set"
  echo "    \$PARALLELY_EMOJI_OUTPUT:"
  echo "        Whether to print emoji."
  echo "        Default: true if output is a tty and \$DISPLAY is set, false otherwise."
  echo "    \$PARALLELY_SHOW_ALL_OUTPUT:"
  echo "        Whether to print command output for successful commands too."
  echo "        Default: false or value of \$ALL_OUTPUT if it is set"
  echo "    \$ENABLE_COLORS: "
  printf '%s' \
       "        If enabled, errors are "
  log_color "$RED" "colored."
  echo "        Default: true if output is a tty, false otherwise."
  echo "    \$SHOW_CMD_OUTPUT_CMD:"
  echo "        Command for printing stderr and stdout of a command/"
  echo "        Default: $SHOW_CMD_OUTPUT_CMD_DEFAULT"
  echo "        Example values:"
  echo "          Show all output: cat"
  echo "          Show last ten lines: tail -n10"
  echo "          Show output for each command one at a time: less"
  echo "  Running commands:"
  echo "    \$CMD_SHELL:"
  echo "        Which shell to run the commands in."
  echo "        Default: $DEFAULT_CMD_SHELL $CMD_SHELL_ARGS"
  echo "    \$FORCE_SEQUENTIAL:"
  echo "        Run commands sequentially instead of in parallel."
  echo "        Useful if you just want to capture output and get notifications."
  echo "        Default: false"
  echo "  Notifications:"
  echo "    \$CLI_NOTIFY:"
  echo "        Whether to use GUI to notify when a command finishes."
  echo "        Default: false if \$DISPLAY is set, false otherwise."
  echo "    \$NOTIFY_COMMAND:"
  echo "        Command to notify when a command succeeds."
  echo "        Should take two arguments, each possibly containing spaces."
  echo "        First argument is title, second is a description."
  echo "        Default: echo if \$CLI_NOTIFY is false, GUI command otherwise."
  echo "    \$FAILURE_NOTIFY_COMMAND:"
  echo "        Command to notify when a command fails."
  echo "        Should take two arguments, each possibly containing spaces."
  echo "        First argument is title, second is a description."
  echo "        Default: echo if \$CLI_NOTIFY is false, more visible GUI command otherwise."
  echo
  echo "Examples:"
  echo
  echo "  Multiple commands:"
  echo "    $SCRIPT_NAME fail 'echo failure && exit 1' \\"
  echo "      fail-printf-nonewline 'printf \"%s %s\"\\ abc 123 ; false' \\"
  echo "      fail-rsync-src 'rsync -rhP nonexistentdir backup' \\"
  echo "      delay 'sleep 0.2' \\"
  echo "      fail-slower-delay '! sleep 0.4' \\"
  echo "      fail-no-output 'exit 210'"
  echo
  echo "    The odd numbered arguments are short, filesafe names for each command." 
  echo "    The names are used in notifications and files storing outout."
  echo
  echo "  A command without arguments:"
  echo "    $SCRIPT_NAME list-files ls"
  echo
  echo "  Verbose output and a command without arguments:"
  echo "    VERBOSE=true $SCRIPT_NAME list-files ls"
  echo "    PARALLELY_VERBOSE_OUTPUT=true $SCRIPT_NAME list-files ls"
  echo
  echo "  A command with arguments:"
  echo "    $SCRIPT_NAME rsync-src 'rsync -rhP src backup'"
  echo
  echo "  A command with arguments that have spaces in them:"
  echo "    $SCRIPT_NAME printf-abc 'printf \"%s %s\" abc 123'"
  echo
  echo "  Shell commands:"
  echo "    $SCRIPT_NAME test-exit 'echo failure && exit 1'"
  echo "    $SCRIPT_NAME test-statement 'if true; then echo 1; fi'"
  echo
  echo "    Commands are run in the $CMD_SHELL shell with: $CMD_SHELL_WITH_ARGS \"\$COMMAND\""
  echo
  echo "  Commands are waited one at a time in order:"
  echo "    This means that you should list the fast commands first."
  echo "    VERBOSE=true $SCRIPT_NAME 1 'sleep 0.1' 2 'sleep 1' 3 'sleep 2'"
  echo
  echo "    Or else, it'll take a bit longer to see successful outputs."
  echo "    VERBOSE=true $SCRIPT_NAME 3 'sleep 2' 2 'sleep 1' 1 'sleep 0.1'"
  echo
  echo "    Regardless, you are notified as soon as a command finishes."
  echo "    VERBOSE=true CLI_NOTIFY=true parallely 3 'sleep 2' 2 'sleep 1' 1 'sleep 0.1'"
  echo
  echo "Contributors: Hugo O. Rivera"
  echo "Version: $VERSION"
}

############## Parse command line arguments
if [ "$#" = 0 ]; then
  help
  error Expected more arguments.
  exit 0
fi

if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
  help
  exit 0
fi

if [ "$1" = "--version" ] || [ "$1" = "-v" ]; then
  log "$VERSION"
  exit 0
fi

if [ $(($# % 2 )) != 0 ]; then
  help
  error Expected even number of arguments.
  exit 0
fi

############## Main functions

run_cmd() {
  # Run a command in background and save its stderr and stdout to files
  NAME="$1"
  COMMAND="$2"
  STDERR_FILE="$CMD_OUT_DIR/$NAME.stderr"
  STDOUT_FILE="$CMD_OUT_DIR/$NAME.stdout"
  TIME_FILE="$CMD_OUT_DIR/$NAME.time"

  # Run command and then run notify command.
  # If notify command fails, do not count the command as a failed command
  # TODO print command that ran in notification. Account for commands
  # like 
    ( \
      ( \
        export START_TIME="$(time_in_sec)"
        $CMD_SHELL_WITH_ARGS \
        "$COMMAND" > "$STDOUT_FILE" 2> "$STDERR_FILE" \
        ; \
        export STATUS_CODE="$?" \
        ; \
        echo "$(time_in_sec)" "$START_TIME" | awk '{print $1 - $2}' > "$TIME_FILE" \
        ; \
        exit "$STATUS_CODE" \
        ; \
      ) \
      && ( \
        $NOTIFY_COMMAND "parallely: $NAME command finished" "$COMMAND" \
        || true \
      ) \
    ) \
    || ( \
      $FAILURE_NOTIFY_COMMAND "parallely: $NAME command failed" "$COMMAND" \
      && false \
    ) \
    &
  PID="$!"
  pids="$pids $PID"
  PID_FILE="$CMD_OUT_DIR/$PID"
  COMMAND_FILE="$CMD_OUT_DIR/$NAME.command"
  echo "$NAME" > "$PID_FILE"
  echo "$COMMAND" > "$COMMAND_FILE"
  verbose "Starting $NAME command $CURRENT_CMD/$NUM_CMDS"
  verbose + "$CMD_SHELL_WITH_ARGS" "$COMMAND"

  if [ "$FORCE_SEQUENTIAL" = true ]; then
    log "FORCE_SEQUENTIAL is set: Waiting for $NAME command to finish"
    wait "$PID"
  fi
}

log "$SCRIPT_NAME will run $NUM_CMDS commands in parallel $(emoji rocket)"

verbose_section Configuration
verbose "PARALLELY_VERBOSE_OUTPUT=$PARALLELY_VERBOSE_OUTPUT"
if [ -n "${VERBOSE-}" ]; then
  verbose "PARALLELY_VERBOSE_OUTPUT set from VERBOSE"
fi
verbose "PARALLELY_EMOJI_OUTPUT=$PARALLELY_EMOJI_OUTPUT"
verbose "CMD_SHELL=$CMD_SHELL"
verbose "FORCE_SEQUENTIAL=$FORCE_SEQUENTIAL"
verbose "SHOW_CMD_OUTPUT_CMD=$SHOW_CMD_OUTPUT_CMD"
verbose "NOTIFY_COMMAND=$NOTIFY_COMMAND"
verbose "FAILURE_NOTIFY_COMMAND=$FAILURE_NOTIFY_COMMAND"
verbose "ENABLE_COLORS=$ENABLE_COLORS"
verbose "Saving command output in CMD_OUT_DIR=$CMD_OUT_DIR"
verbose 

############## Main loop

# Iterate through all given command line arguments.
# Run each one as a command in parallel, saving its output to a tmp file.
START_TIME="$(time_in_sec)"
verbose_section Starting commands
while [ "$#" -gt 0 ]; do
  # TODO what if name is not unique?
  NAME="$1"
  COMMAND="$2"
  CURRENT_CMD="$(( CURRENT_CMD + 1))"
  shift
  shift
  run_cmd "$NAME" "$COMMAND"
done

verbose

############## Wait for commands and show results, especially from failed commands
show_output() {
  # Print output of a command
  DISPOSITION="$1"
  OUTPUT_NAME="$2"
  NAME="$3"
  FILE="$4"
  printf "%s" "$(color "$BLUE")$OUTPUT_NAME$(color "$NONE") output for $DISPOSITION command $NAME:"
  if [ -z "$(cat "$FILE")" ]; then
    log_color "$GREY" " $NO_OUTPUT_INDICATOR"
  else
    log
    log + "$SHOW_CMD_OUTPUT_CMD" "$FILE"
    $SHOW_CMD_OUTPUT_CMD "$FILE"
    if [ "$(tail -c1 "$FILE")" != "$(printf "\n")" ]; then
      log
      log_color "$GREY" "$NO_EOF_NEWLINE_INDICATOR"
    fi
  fi
}

subtract_two_floats() {
  A="$1"
  B="$2"
  SUBTRACT_FAILURE=false
  if command -v awk &> /dev/null; then
    if ! echo "$A" "$B" | awk '{print $1-$2}'; then
      error "awk is not working! Please redefine the subtract_two_floats function"
      SUBTRACT_FAILURE=true
    fi
  else
    error "awk is not available! Please redefine the subtract_two_floats function"
    SUBTRACT_FAILURE=true
  fi
  
  if [ "$SUBTRACT_FAILURE" = true ]; then
    echo "$A - $B"
  fi
}

FAILURE=false
FAILED_CMDS=""
FAILURES=0
SUCCESS=0
failedpids=""
# Wait for commands
verbose_section Waiting for commands to finish
verbose Will list successful and failed commands.
verbose
FORCE_LOG=false
if [ "$PARALLELY_VERBOSE_OUTPUT" != true ] && [ "$PARALLELY_SHOW_ALL_OUTPUT" = true ]; then
  FORCE_LOG=true
fi

for PID in $pids; do
  if wait "$PID"; then
    SUCCESS="$((SUCCESS + 1))"
    if [ "$SUCCESS" = 1 ]; then
      verbose_section "Successful command(s)"
    fi

    NAME="$(cat "$CMD_OUT_DIR/$PID")"
    STDERR_FILE="$CMD_OUT_DIR/$NAME.stderr"
    STDOUT_FILE="$CMD_OUT_DIR/$NAME.stdout"
    TIME="$(cat "$CMD_OUT_DIR/$NAME.time")"
    COMMAND="$(cat "$CMD_OUT_DIR/$NAME.command")"
    verbose "$(emoji checkmark)Command $NAME succeeded in $TIME seconds."
    verbose + "$COMMAND"
    verbose "$STDERR_FILE"
    verbose "$STDOUT_FILE"
    if [ "$PARALLELY_SHOW_ALL_OUTPUT" = true ]; then
      show_output successful STDERR "$NAME" "$STDERR_FILE"
      show_output successful STDOUT "$NAME" "$STDOUT_FILE"
    fi
    verbose
  else
    FAILURE=true
    failedpids="$failedpids $PID"
  fi
done
FORCE_LOG=false

for PID in $failedpids; do
  FAILURES="$((FAILURES + 1))"
  NAME="$(cat "$CMD_OUT_DIR/$PID")"
  FAILED_CMDS="$NAME $FAILED_CMDS"

  if [ "$FAILURES" = 1 ]; then
    error_section "Failed command $(noun "$(echo "$failedpids" | wc -w)" output)"
  fi

  STDERR_FILE="$CMD_OUT_DIR/$NAME.stderr"
  STDOUT_FILE="$CMD_OUT_DIR/$NAME.stdout"
  TIME="$(cat "$CMD_OUT_DIR/$NAME.time")"
  COMMAND="$(cat "$CMD_OUT_DIR/$NAME.command")"
  error "Failure in command $NAME after $TIME seconds"
  log + "$COMMAND"
  log "$STDERR_FILE"
  log "$STDOUT_FILE"
  show_output failed STDERR "$NAME" "$STDERR_FILE"
  show_output failed STDOUT "$NAME" "$STDOUT_FILE"
  if [ "$NEWLINE_AFTER_EVERY_ERROR" = true ]; then
    log
  fi
done

TOTAL_TIME="$(subtract_two_floats "$(time_in_sec)" "$START_TIME")"

############## Print summary and timing
verbose_section SUMMARY
verbose "$SUCCESS $(noun "$SUCCESS" command) succeeded"
log "$NUM_CMDS $(noun "$NUM_CMDS" command) finished in $TOTAL_TIME $(noun "$TOTAL_TIME" second)"
if [ "$FAILURE" = true ]; then
  error "$FAILURES/$NUM_CMDS $(noun "$FAILURES" command) failed: $FAILED_CMDS"
  exit 1
fi
